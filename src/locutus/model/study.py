from . import Serializable
from marshmallow import Schema, fields, post_load

from locutus.model.datadictionary import DataDictionary
from locutus.model.table import Table 
from locutus.model.reference import Reference

from locutus.model.harmony_export import HarmonyFormat, HarmonyOutputFormat, basic_date
from locutus.model.harmony_export import harmony_exporter as build_harmony_exporter


"""
A Study represents a research study which will likely contain one or more
datasets which conform to a single data-dictionary. 

The study objects will live within their own collection and will, therefore, 
have their own id. 

Id:
This should be generated by the system, but can be provided by the user. 

Name (required):
A Human friendly name associated with the study. 

Title (required):
The study's formal title

URL (required):
The study's "system" identifier. 

Description:
An optional block of text that is used to provide context for understanding the
study's purpose.

Identifier-Prefix:
This is used when generating FHIR systems for identifiers. 

Data-Dictionary:
This will be references to the data-dictionaries associated with the study

"""

def build_combined_harmony(study_ids="",
                dd_ids="",
                table_ids="",
                harmony_format=HarmonyFormat.Whistle,
                harmony_output_format=HarmonyOutputFormat.JSON,
                version=None):
    """Build a harmony file based on piecemeal components
    
    study_ids, dd_ids, table_ids all must be strings. Multiple IDs can be 
    provided as a comma separated list of IDs (no whitespace). 

    study_ids="st-asdfvdsa", "st-23432",
    tablie_ids="tb-gfdsasdf"

    The above example would generate one harmony response containing all data 
    from both studies above in addition to the table, tb-fgdsasdf
    """
    harmony_exporter = build_harmony_exporter(harmony_format=harmony_format, output_format=harmony_output_format)
    total_mappings = []

    if version is None:
        version = basic_date()

    if study_ids != "":
        for study_id in study_ids.split(","):
            study = Study.get(study_id)

            if study:
                total_mappings += study.as_harmony(harmony_exporter=harmony_exporter,
                version=version)

    if dd_ids != "":
        for dd_id in dd_ids.split(","):
            dd = DataDictionary.get(dd_id)

            if dd:
                total_mappings += dd.as_harmony(harmony_exporter=harmony_exporter,
                version=version)
    
    if table_ids != "":
        for table_id in table_ids.split(","):
            table = Table.get(table_id)

            if table:
                total_mappings += table.as_harmony(harmony_exporter=harmony_exporter,
                version=version)                
    
    return total_mappings 

class Study(Serializable):
    _id_prefix = "st"

    def __init__(
        self,
        id=None,
        _id=None,
        name=None,
        description=None,
        identifier_prefix="",
        title=None,
        url="",
        datadictionary=None,
        resource_type=None,
    ):
        super().__init__(id=id, _id=_id, collection_type="Study", resource_type="Study")
        self.name = name
        self.description = description
        self.identifier_prefix = identifier_prefix
        self.title = title
        self.url = url

        self.datadictionary = []
        if datadictionary is not None:
            self.datadictionary = [Reference(dd["reference"]) for dd in datadictionary]

        super().identify()

    def remove_dd(self, id):
        matching_references = []

        treference = f"DataDictionary/{id}"

        idx = 0
        for ref in self.datadictionary:
            if ref.reference == treference:
                matching_references.append(idx)
            idx += 1

        if len(matching_references) > 0:
            for ref in matching_references:
                del self.datadictionary[ref]

        return len(matching_references)

    def keys(self):
        return [self.title, self.url, self.name]

    def as_harmony(self, 
                harmony_exporter=None,
                harmony_format=HarmonyFormat.Whistle,
                harmony_output_format=HarmonyOutputFormat.JSON,
                version=None):

        if version is None:
            version = basic_date()

        if harmony_exporter is None:
            harmony_exporter = build_harmony_exporter(harmony_format=harmony_format, output_format=harmony_output_format)

        total_mappings = []
        for dd in self.datadictionary:
            total_mappings += dd.dereference().as_harmony(harmony_exporter=harmony_exporter,
                study_title=self.title,
                study_name=self.name,
                study_id=self.id,
                version=version)
        
        return total_mappings


    class _Schema(Schema):
        id = fields.Str()
        name = fields.Str(required=True)
        description = fields.Str()
        identifier_prefix = fields.URL()
        title = fields.Str(required=True)
        url = fields.URL()
        resource_type = fields.Str()

        # For now, we'll just cache the reference ID
        datadictionary = fields.List(fields.Nested(Reference._Schema))

        @post_load
        def build_terminology(self, data, **kwargs):
            return Study(**data)
