from . import Serializable
from marshmallow import Schema, fields, post_load
from locutus import (
    persistence,
    strip_none,
    FTD_PLACEHOLDERS,
    normalize_ftd_placeholders,
)
from flask import request

from locutus.model.variable import Variable, InvalidVariableDefinition
from locutus.model.reference import Reference
from locutus.model.terminology import Terminology
from locutus.model.exceptions import *

from locutus.api import default_headers


import pdb
import rich

import sys

"""
A Table represents a collection of dataset "variables", typically organized
as a list, such as one might find inside a CSV file. 

Tables will exist in their own collection and have an id which can be used to
reference them from within a data-dictionary. 

Id:
This should be generated by the system, but can be provided by the user. 

Name (required):
A Human friendly name associated with the table. 

URL (required):
The table's "system" identifier. 

filename:
This is a bit of a relic that is used to refer back to the initial source from
which the table was defined. 

Description:
An optional block of text that is used to provide context for understanding the
table's purpose.


Shadow Terminology: Each table must have a terminology which reflects each of 
variables in the table as terms. This terminology must be changed to reflect
the table with any changes. 
"""


class Table(Serializable):
    _id_prefix = "tb"

    def __init__(
        self,
        id=None,
        code="",
        name=None,
        url=None,
        description=None,
        filename=None,
        variables=[],
        terminology=None,
        resource_type="Table",
        editor=None,
    ):

        super().__init__(id=id, collection_type="Table", resource_type="Table")

        if strip_none(code) == "":
            code = strip_none(name)

        self.id = id
        self.name = name
        self.code = code
        self.description = description
        self.filename = filename
        self.url = url
        self.variables = []
        self._terminology = None

        # For the time being, since old tables don't have them, we must create
        # the shadow terminologies on the fly. If we do this, we need to save
        # the table, but only after we've repopulated it with the corresponding
        # variables.
        added_terminology = False

        # This represents the "shadow" terminology that reflects the variable
        # names and descriptions associated with a given table.
        if terminology:
            # pdb.set_trace()
            self.terminology = Reference(reference=terminology["reference"])
        else:
            # pdb.set_trace()
            terminology = {
                "name": name,
                "url": f"{url}/{name}",
                "description": self.description,
                "codes": [],
            }
            t = Terminology(**terminology)
            t.save()
            print(
                f"Creating Shadow Terminology for table: {self.name} -- Terminology ID: {t.id}"
            )
            self.terminology = Reference(f"Terminology/{t.id}", t)
            added_terminology = True

        for var in variables:
            # We definitely don't want to add provenance when we are reloading resources from the database
            self.add_variable(var, editor=editor)

        super().identify()

        if added_terminology:
            self.save()

    def remove_variable(self, varname, editor):
        success = False
        for var in self.variables:
            coding = (
                normalize_ftd_placeholders(var.name)
                if var.name in FTD_PLACEHOLDERS
                else var.name
            )
            if coding == varname:
                # TODO: How to handle deleting enumerated variables tables
                # For now, I am not willing to handle enumerated variables
                # differently, since it could result in unwittingly deleting
                # something that is intended to remain. That is something
                # real to address, though.
                print(f"Removing variable '{varname}' from {self.name}.")
                # pdb.set_trace()
                self.variables.remove(var)
                self.terminology.dereference().remove_code(code=var.code, editor=editor)
                success = True
                return
        if not success:
            msg = f"The table, '{self.name}' ({self.id}), has no code, '{varname}'"
            print(msg)
            raise KeyError(msg)

    def rename_var(self, original_varname, new_varname, new_description, editor):
        status = 200

        print(
            f"Renaming Variable, {original_varname} to {new_varname} with new desc: {new_description}"
        )
        old_values = []
        new_values = []

        terms = self.terminology.dereference()
        for var in self.variables:
            # print(f"{self.name} - {var.name} == {original_varname}")
            if var.name == original_varname:
                original_code = var.code

                # It's not unreasonable we have only been asked to update the
                # display, so no need to wastefully change all of the details
                # about the code when the end result is the same
                if original_varname != new_varname:
                    old_values.append(f"variable: {original_varname}")
                    new_values.append(f"variable: {new_varname}")
                    var.name = new_varname
                    var.code = new_varname
                    if var.code != original_code:

                        # Since we found a matching code, we'll pull the mappings and
                        # save those under the new code after deleting the old ones.

                        mappings = terms.mappings(original_code)
                        if original_code in mappings and mappings[original_code] != []:
                            terms.set_mapping(
                                var.code, mappings[original_code], editor=editor
                            )
                            terms.delete_mappings(code=original_code, editor=editor)

                if new_description is not None:
                    old_values.append(f"description: {var.description}")
                    new_values.append(f"description: {new_description}")
                    var.description = new_description

                old_values = ",".join(old_values)
                new_values = ",".join(new_values)

                self.save()
                if new_values:
                    terminology = self.terminology.dereference()
                    terminology.add_provenance(
                        change_type=Terminology.ChangeType.EditTerm,
                        target=original_code,
                        old_value=old_values,
                        new_value=new_values,
                        editor=editor,
                    )
                    terminology.add_provenance(
                        change_type=Terminology.ChangeType.EditTerm,
                        target="self",
                        old_value=old_values,
                        new_value=new_values,
                        editor=editor,
                    )
                    if original_varname != new_varname:
                        term_doc = (
                            persistence()
                            .collection(terminology.resource_type)
                            .document(terminology.id)
                            .collection("provenance")
                        )
                        prov = term_doc.document(original_code).get().to_dict()
                        prov["target"] = var.code
                        term_doc.document(var.code).set(prov)
                        term_doc.document(original_code).delete()
                return True
        return False

    def _insert_variable(self, variable):
        """If aa variable with the same name exists, replace it. Else append"""

        for idx, var in enumerate(self.variables):
            # pdb.set_trace()
            if variable.name == var.name:
                self.variables[idx] = variable
                return True
        self.variables.append(variable)

    def add_variable(self, variable, editor=None):
        v = variable
        # Ensure the name is not a ftd_placeholder
        name = (
            normalize_ftd_placeholders(v["name"])
            if v["name"] in FTD_PLACEHOLDERS
            else v["name"]
        )

        if type(variable) is dict:
            # For now, let's insure that the enumerations terminology is there or
            # create an empty one if not. This may need to be moved into the
            # variable itself.

            if v["data_type"] == "ENUMERATION":
                if "enumerations" not in v or len(v["enumerations"]) < 1:
                    # Create an empty terminology and create a reference to that
                    # terminology
                    t = Terminology(
                        name=name,
                        description=v.get("description"),
                        url=f"{self.url}/{name}",
                    )
                    t.save()

                    reference = f"Terminology/{t.id}"
                    v["enumerations"] = {"reference": reference}

            # pdb.set_trace()
            v = Variable.deserialize(variable)
            self._insert_variable(v)
        else:
            self._insert_variable(variable)

        try:
            self.terminology.dereference().add_code(
                code=v.code, display=v.name, editor=editor
            )
        except CodeAlreadyPresent as e:
            pass

    def build_harmony_row(self, local_coding, mapped_coding):

        return {
            "local code": local_coding.code,
            "text": local_coding.display,
            "table_name": self.name,
            "parent_varname": "",  # I'm not sure if we can get this ATM
            "local code system": local_coding.system,
            "mapping relationship": mapped_coding.mapping_relationship,
            "code": mapped_coding.code,
            "display": mapped_coding.display,
            "code system": mapped_coding.system,
            "comment": "",
        }

    def harmonize_mappings(self, codings, mappings, harmony_mappings, var_name=None):
        for code in mappings:
            if code not in codings:
                allowed_codes = "'" + "','".join(codings.keys()) + "'"
                print(
                    f"WARNING: The code, {code}, from variable, {self.name}:{var_name}, doesn't match any of the available codes: {allowed_codes}\n"
                )
            else:
                coding = codings[code]

                mapped_codings = mappings[code]

                for mc in mapped_codings:
                    harmony_row = self.build_harmony_row(coding, mc)
                    if harmony_row is not None:
                        harmony_mappings.append(harmony_row)

    def as_harmony(self):
        # Iterate over each table
        harmony_mappings = []
        # pdb.set_trace()
        if self.terminology is not None:
            shadow = self.terminology.dereference()
            table_mappings = shadow.mappings()
            table_codings = shadow.build_code_dict()
            self.harmonize_mappings(table_codings, table_mappings, harmony_mappings)
        for var in self.variables:
            if var.data_type == Variable.DataType.ENUMERATION:
                term = var.get_terminology()

                # Capture a dictionary with code=>coding
                codings = term.build_code_dict()
                mappings = var.get_mappings()
                self.harmonize_mappings(codings, mappings, harmony_mappings, var.name)
        return harmony_mappings

    def keys(self):
        return [self.url, self.name]

    def get_preference(self, code=None):
        """Retrieve preferences from the terminology or fall back to table 
        preferences if none are found.
        
        If no VALID code is provided: returns Table preferences
        If code is provided, and preferences exist: returns the Code preferences.
        If code is provided, and no prefs exist: ruturns Table preferences.
        """
        try:
            pref = self.terminology.dereference().get_preference(code=code)

            # If code exists as a key and is empty get the Table preferences.
            if code in pref and not pref[code]:
                table_pref = self.terminology.dereference().get_preference(code="self")
                return table_pref if table_pref else {}

            return pref

        except Exception as e:
            print(f"An error occurred while retrieving preferences: {str(e)}")
            raise

    def add_or_update_pref(self, api_preference, code=None):
        try:
            self.terminology.dereference().add_or_update_pref(
                api_preference=api_preference, code=code
            )

        except Exception as e:
            print(f"An error occurred while updating preferences: {str(e)}")
            raise

    def remove_pref(self, code=None):
        try:
            message = self.terminology.dereference().remove_pref(code=code)
            return message
        except Exception as e:
            print(f"An error occurred while updating preferences: {str(e)}")
            raise

    def get_preferred_terminology(self):
        """
        Retrieves all references from the 'preferred_terminology' sub-collection

        Returns:
            list: 'references" - An array of `Terminology` reference dictionaries
        
        Example output:
        {
            "references": [
                {
                    "reference": "Terminology/tm--example1"
                },
                {
                    "reference": "Terminology/tm--example2"
                }
            ]
        } 
        """
        try:
            pref = self.terminology.dereference().get_preferred_terminology()

            return pref

        except Exception as e:
            print(f"An error occurred while retrieving preferred terminology: {e}")
            raise

    def replace_preferred_terminology(self, editor, preferred_terminology):
        """
        Creates or replaces a document in the 'preferred_terminology' sub-collection

        Args:
            preferred_terminology (list): A dictionary representing the preferred terminology to be added.

        JSON body with two additions example:
        [
            {
                "preferred_terminology": "tm--example1"
            },
            {
                "preferred_terminology": "tm--example2"
            }
        ]
        """
        try:
            self.terminology.dereference().replace_preferred_terminology(
                editor,preferred_terminology
            )

        except Exception as e:
            print(f"An error occurred while updating preferences: {str(e)}")
            raise

    def remove_preferred_terminology(self):
        """
        Creates or replaces a document in the 'preferred_terminology' sub-collection

        Args:
            preferred_terminology (list): A dictionary representing the preferred terminology to be added.

        JSON body with two additions example:
        [
            {
                "preferred_terminology": "tm--example1"
            },
            {
                "preferred_terminology": "tm--example2"
            }
        ]
        """
        try:
            self.terminology.dereference().remove_preferred_terminology()

        except Exception as e:
            print(f"An error occurred while updating preferences: {str(e)}")
            raise

    class _Schema(Schema):
        id = fields.Str()
        code = fields.Str()
        name = fields.Str(required=True)
        url = fields.URL(required=True)
        filename = fields.Str()
        description = fields.Str()
        variables = fields.List(fields.Nested(Variable._Schema))
        resource_type = fields.Str()
        terminology = fields.Nested(Reference._Schema)

        @post_load
        def build_terminology(self, data, **kwargs):
            return Table(**data)

    def dump(self):
        content = self.__class__._get_schema().dump(self)
        content["variables"] = [v.dump() for v in self.variables]
        # pdb.set_trace()

        return content
