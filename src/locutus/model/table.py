from . import Serializable
from marshmallow import Schema, fields, post_load
from locutus import persistence

from locutus.model.variable import Variable
from locutus.model.reference import Reference
from locutus.model.terminology import Terminology, CodeAlreadyPresent

import pdb

import sys

"""
A Table represents a collection of dataset "variables", typically organized
as a list, such as one might find inside a CSV file. 

Tables will exist in their own collection and have an id which can be used to
reference them from within a data-dictionary. 

Id:
This should be generated by the system, but can be provided by the user. 

Name (required):
A Human friendly name associated with the table. 

URL (required):
The table's "system" identifier. 

filename:
This is a bit of a relic that is used to refer back to the initial source from
which the table was defined. 

Description:
An optional block of text that is used to provide context for understanding the
table's purpose.


Shadow Terminology: Each table must have a terminology which reflects each of 
variables in the table as terms. This terminology must be changed to reflect
the table with any changes. 
"""


class Table(Serializable):
    _id_prefix = "tb"

    def __init__(
        self,
        id=None,
        name=None,
        url=None,
        description=None,
        filename=None,
        variables=[],
        terminology=None,
        resource_type="Table",
    ):
        super().__init__(id=id, collection_type="Table", resource_type="Table")
        self.id = id
        self.name = name
        self.description = description
        self.filename = filename
        self.url = url
        self.variables = []
        self._terminology = None

        # For the time being, since old tables don't have them, we must create
        # the shadow terminologies on the fly. If we do this, we need to save
        # the table, but only after we've repopulated it with the corresponding
        # variables.
        added_terminology = False

        # This represents the "shadow" terminology that reflects the variable
        # names and descriptions associated with a given table.
        if terminology:
            # pdb.set_trace()
            self.terminology = Reference(reference=terminology["reference"])
        else:
            # pdb.set_trace()
            terminology = {
                "name": name,
                "url": f"{url}/{name}",
                "codes": [],
            }
            t = Terminology(**terminology)
            t.save()
            print(
                f"Creating Shadow Terminology for table: {self.name} -- Terminology ID: {t.id}"
            )
            self.terminology = Reference(f"Terminology/{t.id}", t)
            added_terminology = True

        for var in variables:
            self.add_variable(var)

        super().identify()

        if added_terminology:
            self.save()

    def remove_variable(self, varname):
        success = False
        for var in self.variables:
            if var.name == varname:
                # TODO: How to handle deleting enumerated variables tables
                # For now, I am not willing to handle enumerated variables
                # differently, since it could result in unwittingly deleting
                # something that is intended to remain. That is something
                # real to address, though.
                print(f"Removing variable '{varname}' from {self.name}.")
                # pdb.set_trace()
                self.variables.remove(var)
                self.terminology.dereference().remove_code(var.name)
                success = True
                return
        if not success:
            msg = f"The table, '{self.name}' ({self.id}), has no code, '{varname}'"
            print(msg)
            raise KeyError(msg)

    def rename_var(self, original_varname, new_varname, new_description):
        status = 200

        print(
            f"Renaming Variable, {original_varname} to {new_varname} with new desc: {new_description}"
        )

        terms = self.terminology.dereference()
        for var in self.variables:
            # print(f"{self.name} - {var.name} == {original_varname}")
            if var.name == original_varname:

                # It's not unreasonable we have only been asked to update the
                # display, so no need to wastefully change all of the details
                # about the code when the end result is the same
                if original_varname != new_varname:
                    var.name = new_varname

                    # Since we found a matching code, we'll pull the mappings and
                    # save those under the new code after deleting the old ones.

                    mappings = terms.mappings(original_varname)
                    if (
                        original_varname in mappings
                        and mappings[original_varname] != []
                    ):
                        terms.set_mapping(new_varname, mappings[original_varname])
                        terms.delete_mappings(original_varname)

                if new_description is not None:
                    var.description = new_description
                self.save()
                return True
        return False

    def _insert_variable(self, variable):
        """If aa variable with the same name exists, replace it. Else append"""

        for idx, var in enumerate(self.variables):
            # pdb.set_trace()
            if variable.name == var.name:
                self.variables[idx] = variable
                return True
        self.variables.append(variable)

    def add_variable(self, variable):
        v = variable

        if type(variable) is dict:
            # For now, let's insure that the enumerations terminology is there or
            # create an empty one if not. This may need to be moved into the
            # variable itself.

            if v["data_type"] == "ENUMERATION":
                if "enumerations" not in v or len(v["enumerations"]) < 1:
                    # Create an empty terminology and create a reference to that
                    # terminology
                    t = Terminology(
                        name=v["name"],
                        description=v.get("description"),
                        url=f"{self.url}/{v['name']}",
                    )
                    t.save()

                    reference = f"Terminology/{t.id}"
                    v["enumerations"] = {"reference": reference}

            v = Variable.deserialize(variable)
            self._insert_variable(v)
        else:
            self._insert_variable(variable)

        try:
            self.terminology.dereference().add_code(code=v.name, display=v.description)
        except CodeAlreadyPresent as e:
            pass

    def build_harmony_row(self, local_coding, mapped_coding):

        return {
            "local code": local_coding.code,
            "text": local_coding.display,
            "table_name": self.name,
            "parent_varname": "",  # I'm not sure if we can get this ATM
            "local code system": local_coding.system,
            "code": mapped_coding.code,
            "display": mapped_coding.display,
            "code system": mapped_coding.system,
            "comment": "",
        }

    def as_harmony(self):
        # Iterate over each table
        harmony_mappings = []
        # pdb.set_trace()
        if self.terminology is not None:
            shadow = self.terminology.dereference()
            table_mappings = shadow.mappings()
            table_codings = shadow.build_code_dict()
            for code in table_mappings:
                if code not in table_codings:
                    allowed_codes = "'" + "','".join(table_codings.keys()) + "'"
                    print(
                        f"WARNING: The code, {code}, from variable, {self.name}:{var.name}, doesn't match any of the available codes: {allowed_codes}\n"
                    )
                else:
                    coding = table_codings[code]

                    mapped_codings = table_mappings[code]

                    for mc in mapped_codings:
                        harmony_row = self.build_harmony_row(coding, mc)
                        if harmony_row is not None:
                            harmony_mappings.append(harmony_row)
        for var in self.variables:
            if var.data_type == Variable.DataType.ENUMERATION:
                term = var.get_terminology()

                # Capture a dictionary with code=>coding
                codings = term.build_code_dict()

                mappings = var.get_mappings()
                for code in mappings:

                    if code not in codings:
                        allowed_codes = "'" + "','".join(codings.keys()) + "'"
                        print(
                            f"WARNING: The code, {code}, from variable, {self.name}:{var.name}, doesn't match any of the available codes: {allowed_codes}\n"
                        )
                    else:
                        coding = codings[code]

                        mapped_codings = mappings[code]

                        for mc in mapped_codings:
                            harmony_row = self.build_harmony_row(coding, mc)
                            if harmony_row is not None:
                                harmony_mappings.append(harmony_row)
        return harmony_mappings

    def keys(self):
        return [self.url, self.name]

    class _Schema(Schema):
        id = fields.Str()
        name = fields.Str(required=True)
        url = fields.URL(required=True)
        filename = fields.Str()
        description = fields.Str()
        variables = fields.List(fields.Nested(Variable._Schema))
        resource_type = fields.Str()
        terminology = fields.Nested(Reference._Schema)

        @post_load
        def build_terminology(self, data, **kwargs):
            return Table(**data)

    def dump(self):
        content = self.__class__._get_schema().dump(self)
        content["variables"] = [v.dump() for v in self.variables]
        # pdb.set_trace()

        return content
