from .serializable import Serializable
from marshmallow import Schema, fields, post_load

import locutus 

from locutus.api import delete_collection, generate_paired_string, generate_mapping_index
import locutus.model.exceptions
import locutus.model.lookups 
from enum import StrEnum  # Adds 3.11 requirement or 3.6+ with StrEnum library
from datetime import datetime
import time
from locutus import logger

from locutus.model.user_input import MappingConversation, MappingVote
from locutus.model.lookups import FTDConceptMapTerminology, FTDOntologyLookup
from locutus.model.onto_api_preference import OntoApiPreference
import locutus.model.provenance
from locutus.model.user_input import UserInput
from locutus.sessions import SessionManager

from locutus.model.coding import Coding, BasicCoding
from locutus.model.reference import Reference
from locutus.model.simple_reference import SimpleReference

import pdb

"""
A terminology exists on its own within the project but can be referenced by 
variables as part of their data-type construction. 

Id:
This should be generated by the system, but can be provided by the user. 

Name:
A Human friendly name associated with the terminology. 

URL:
The terminology's "system" identifier. 

Description:
An optional block of text that is used to provide context for understanding the
terminology's purpose.

Codes:
(Currently, a List) of Codings. Each coding is defined within the scope of the 
terminology's "codes" property. Codings should not appear more than once inside
the "codes" array. 
"""



class Terminology(Serializable):
    _id_prefix = "tm"

    class MappingStatus(StrEnum):
        AwaitingApproval = "Awaiting Approval"
        Approved = "Approved"
        Rejected = "Rejected"

    def __init__(
        self,
        id=None,
        _id=None,
        name=None,
        url=None,
        description=None,
        codes=None,
        resource_type=None,
        preferred_terminologies=[],
        api_preferences={},
        editor=None,
    ):
        super().__init__(
            id=id, _id=_id, collection_type="Terminology", resource_type="Terminology"
        )
        self.name = name
        self.description = description
        self.url = url
        self.codes = []

        self.api_preferences = api_preferences
        self.preferred_terminologies = preferred_terminologies

        super().identify()

        if editor:
            self.save()
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.Create,
                editor=editor,
                target="self",
                new_value="Instantiation"
            )

        if codes is not None:
            for code in codes:              
                ref = None 
                if type(code) is dict:
                    if "reference" in code:
                        ref = SimpleReference(reference=code['reference'])
                    else:
                        code['terminology_id'] = self.id
                        code['system'] = self.url
                        if self.url is None:
                            logger.debug(f"Attempting to assign "" as system from the following Terminology: ")
                            logger.debug(f"Terminology Name: {self.name}\tTerminology ID: {self.id}")
                            code['system'] = "-"

                        code = Coding(**code)
                if ref is None:                
                    code.system = self.url
                    code.save()
                    ref = SimpleReference(f"Coding/{code.id}")

                self.codes.append(ref)

                if editor:
                    self.add_provenance(
                        locutus.model.provenance.Provenance.ChangeType.AddTerm,
                        editor=editor,
                        target="self",
                        new_value=code.code,
                    )

    def find_match(self, return_instance=True):

        if self.url is not None and self.url.strip() != "" \
            and self.name is not None and self.name.strip() != "":
            params = {
                "url": self.url,
                "name": self.name
            }

            return self.__class__.find(params, return_instance)
        
        raise ValueError(f"Terminology.find_match() requires both a url and name.")

    def delete(self, hard_delete=True):
        t = self.realize_as_dict()
        super().delete(hard_delete=hard_delete)

        # User Input
        for cnv in MappingConversation.get(
            terminology_id=self.id,
            return_instance=True
            ):
            cnv.delete(hard_delete=hard_delete)
        
        for vote in MappingVote.get(
            terminology_id=self.id,
            return_instance=True
            ):
            vote.delete(hard_delete=hard_delete)


        # Delete all provenance
        for prov in locutus.model.provenance.Provenance.find({"terminology_id": self.id}):
            prov.delete(hard_delete=hard_delete)

        all_codings = locutus.model.coding.Coding.get(
                                terminology_id=self.id,
                                valid_only=False
        )
        if type(all_codings) is locutus.model.coding.Coding:
            all_codings = [all_codings]

        for coding in all_codings:
            coding.delete(hard_delete=hard_delete)


        return t

    def keys(self):
        return [self.url, self.name]

    def build_code_dict(self):
        codings = {}

        for cref in self.codes:
            coding = cref.dereference()
            codings[coding.code] = coding 

        return codings

    """
    def build_code_list(mapping):
        codes = []
        code_id = mapping["code"]

        for codingmapping in mapping["codes"]:
            codes.append(CodingMapping(**codingmapping))

        return codes
    """

    def add_code(self, code, display, description=None, terminology_id=None, editor=None, exists_ok=True):
        coding = None 
        new_to_codes = True 
        if type(code) is str:
            # If it is already in codes, we can just return
            coding = self.get_coding(code)

            if coding is not None:
                new_to_codes = False 
            else:
                # If it's not in codes, but it is in the database...
                coding = locutus.model.coding.Coding.get(
                            terminology_id=self.id,
                            code=code)

                if coding == []:
                    coding = None 

                if type(coding) is list and len(coding) != 0:
                    # This definitely should not return more than one coding
                    raise locutus.model.exceptions.InvalidValueError(code, "too many codes already exist in the database")

            # Finally, the code is not really new, so all we are doing is updating valid status
            if coding is not None:
                if coding.valid is False:
                    self.add_provenance(
                        locutus.model.provenance.Provenance.ChangeType.EditTerm, 
                        editor=editor,
                        target="self",
                        new_value="valid=True",
                        old_value="valid=False"
                    )
                    coding.valid = True 
                    coding.save()
                elif not exists_ok:
                    raise locutus.model.exceptions.CodeAlreadyPresent(code, self.id, coding.dump())
                
                if new_to_codes:
                    self.codes.append(SimpleReference(f"Coding/{coding.id}"))
                    self.save()                    
                return 

        new_coding = Coding(terminology_id=self.id,
                            code=code, 
                            display=display, 
                            description=description,
                            system=self.url, 
                            editor=editor,
                            rank=len(self.codes)
                            )

        new_coding.save()

        self.codes.append(SimpleReference(f"Coding/{new_coding.id}"))
        self.save()

        if editor:
            # This adds provenance to the Terminology/Table itself
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.AddTerm,
                editor=editor,
                target="self",
                new_value=code,
            )
            # This adds provenance to the code itself
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.AddTerm,
                editor=editor,
                target=code,
            )

    def remove_code(self, code, editor):
        code_found = False
        # Ensure codes are not placeholders at this point.
        code = locutus.normalize_ftd_placeholders(code)

        coding = self.get_coding(code, return_instance=False)
        
        if coding is not None:
            # We might want to actually call self.delete_mappings(code=code)
            # if we want to reflect, in provenance, that we lost some mappings
            # However, that wasn't what we were doing, so leaving things as 
            # they were for now
            # EST - 2025-08-18
            cinstance = coding.dereference()
            cinstance.valid = False
            cinstance.save()
            
            self.codes.remove(coding)
            self.save()
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.RemoveTerm,
                editor=editor,
                target="self",
                new_value=code,
            )
            code_found = True
        else:
            msg = f"The terminology, '{self.name}' ({self.id}), has no code, '{code}'"
            logger.error(msg)
            raise KeyError(msg)

    def rename_code(
        self, original_code, new_code, new_display, editor, new_description=None
    ):
        status = 200
        print(
            f"Renaming Code, {original_code} to {new_code} with new display: {new_display} and new description: {new_description}"
        )
        old_values = []
        new_values = []

        for coderef in self.codes:
            code = coderef.dereference()
            if code.code == original_code:

                # It's not unreasonable we have only been asked to update the
                # display, so no need to wastefully change all of the details
                # about the code when the end result is the same
                if original_code != new_code:
                    old_values.append(f"code: {original_code}")
                    new_values.append(f"code: {new_code}")
                    code.code = new_code

                    # Since we found a matching code, we'll pull the mappings and
                    # save those under the new code after deleting the old ones.
                    mappings = self.mappings(original_code)
                    if original_code in mappings and mappings[original_code] != []:
                        self.set_mapping(new_code, mappings[original_code], editor=editor)
                        self.delete_mappings(code=original_code, editor=editor)

                if new_display is not None and code.display != new_display:
                    old_values.append(f"display: {code.display}")
                    new_values.append(f"display: {new_display}")
                    code.display = new_display

                if new_description is not None and code.description != new_description:
                    old_values.append(f"description: {code.description}")
                    new_values.append(f"description: {new_description}")
                    code.description = new_description

                old_values = ",".join(old_values)
                new_values = ",".join(new_values)


                code.save()
                self.save()
                if new_values:
                    self.add_provenance(
                        change_type=locutus.model.provenance.Provenance.ChangeType.EditTerm,
                        target=original_code,
                        old_value=old_values,
                        new_value=new_values,
                        editor=editor,
                    )
                    self.add_provenance(
                        change_type=locutus.model.provenance.Provenance.ChangeType.EditTerm,
                        target="self",
                        old_value=old_values,
                        new_value=new_values,
                        editor=editor,
                    )
                    if original_code != new_code:
                        prov = locutus.model.provenance.Provenance.mapping_provenance(
                            terminology_id=self.id, 
                            target_coding=original_code, 
                            valid_only=False,
                            return_instance=True
                        )

                        for prv in prov:
                            prv.target=new_code 
                            prv.save()
                    return True
        return False

    def has_code(self, code):
        """Check if a code exists in the terminology.

        Args: 
          code(str): Code to be checked against a Terminologies codes. 
          Terminology codes are currently not cleaned for indexing. For 
          more see get_code_index

        Output:           
         If the terminology has the code already this will return True
        """
        # Ensure codes are not placeholders at this point.
        code = locutus.normalize_ftd_placeholders(code)

        return any(entry.dereference().code == code for entry in self.codes)

    def delete_mappings(self, editor, code=None):
        """
        Soft deletes mappings from a terminology document setting the mapping 
        valid field to false.

        Args:
            editor (str): The ID of the user performing the deletion.
            code (str, optional): The specific mapping code to delete. 

        """
        if code is not None:
            # Ensure codes are not placeholders at this point.
            coding = self.get_coding(code)

            old_values = {
                "code": coding.code,
                "codes": coding.delete_mappings()
            }

            self.add_provenance(
                change_type=locutus.model.provenance.Provenance.ChangeType.SoftDeleteMapping,
                target=code,
                old_value=old_values,
                new_value="deleted",
                editor=editor,
            )
            # coding.save()
            

            if len(old_values['codes']) == 0:
                logger.debug(f"Soft deleting mappings for code: {code}, Terminology: {self.name} but there were no mappings.")

        else:
            for coding in self.codes:
                old_values = {
                    "code": coding.dereference().code,
                    "codes": coding.dereference().delete_mappings()
                }

                self.add_provenance(
                    change_type=locutus.model.provenance.Provenance.ChangeType.SoftDeleteMapping,
                    target=coding.dereference().code,
                    old_value=old_values,
                    new_value="deleted",
                    editor=editor,
                )


            self.add_provenance(
                change_type=locutus.model.provenance.Provenance.ChangeType.SoftDeleteAllMappings,
                target="self",
                old_value="valid=True",
                new_value="valid=False",
                editor=editor,
            )

    def mappings(self, code=None):
        codes = {}

        if code is not None:
            coding = self.get_coding(code)
            if coding is None or coding.mappings is None:
                codes[code] = []
            else:
                codes[code] = coding.mappings
        else:
            for coderef in self.codes:
                code = coderef.dereference()
                codes[code.code] = code.mappings
        return codes

    def get_coding(self, code, return_instance=True, as_reference=False):
        for item in self.codes:
            coding = item.dereference()
            if coding.code == code:
                if return_instance:
                    return coding
                return item

        return None 

    def get_provenance(self, code=None):
        prov = {}

        if code is None or code == 'self':
            # This isn't really relevant any more, but the FE does use it so we will keep it 
            prov['self'] = {}
            prov['self']['target'] = "self"
            changes = []

            for prv in locutus.model.provenance.Provenance.terminology_provenance(terminology_id=self.id):
                if type(prv['timestamp']) is not str:
                    prv['timestamp'] = prv['timestamp'].strftime(
                        locutus.PROVENANCE_TIMESTAMP_FORMAT
                    )
                changes.append(prv)
            prov['self']['changes'] = changes
        else:
            prov[code] = {}
            prov[code]["target"] = code
            changes = []

            for prv in locutus.model.provenance.Provenance.mapping_provenance(terminology_id=self.id, target_coding=code):   
                if prv is not None:             
                    if type(prv['timestamp']) is not str:
                        prv['timestamp'] = prv['timestamp'].strftime(
                            locutus.PROVENANCE_TIMESTAMP_FORMAT
                        )
                    changes.append(prv)
                else:
                    changes = []
            prov[code]['changes'] = changes
        return prov

    def add_provenance(
        self, change_type, editor, target=None, timestamp=None, **kwargs
    ):
        if target is None or target == 'self':
            p = locutus.model.provenance.Provenance.add_terminology_provenance(
                terminology_id=self.id, 
                action=change_type,
                editor=editor,
                timestamp=timestamp,
                **kwargs
            )
        else:
            if target.count("|") > 1:
                print(f"Warning: Invalid target format '{target}'. Skipping provenance addition.")
                return

            if "|" in target:
                left, right = target.split("|", 1)
                # Normalize each side of a paired target for the provenance target/display
                normalized_left = locutus.normalize_ftd_placeholders(left)
                normalized_right = locutus.normalize_ftd_placeholders(right)
                normalized_target = generate_paired_string(normalized_left, normalized_right)

                code_index = target # mapping pairs are already formatted as indexes
            # Ensure special characters in single code targets are handled properly
            else:
                normalized_target = locutus.normalize_ftd_placeholders(target)
                code_index = locutus.get_code_index(target)

            p = locutus.model.provenance.Provenance.add_mapping_provenance(
                terminology_id=self.id, 
                action=change_type,
                editor=editor,
                target_coding=normalized_target,
                timestamp=timestamp,
                **kwargs
            )


    # def add_provenance(self, code, change_type, old_value, new_value, editor, note="via locutus frontend", timestamp=None):

    def set_mapping(self, code, codings, editor):
        code_index = locutus.get_code_index(code)

        # Ensure code is not a placeholder at this point.
        code = locutus.normalize_ftd_placeholders(code)

        new_mappings = []

        coding = self.get_coding(code)
        if coding is None:
            raise locutus.model.exceptions.CodeNotPresent(code, self.id)
        old_mappings = ",".join([x.code for x in coding.mappings])
        
        new_mappings = coding.set_mappings(codings)
        coding.save()

        # Should we move the provenance inside the coding? Probably, but later EST -- 2025-08-26
        change_type = locutus.model.provenance.Provenance.ChangeType.AddMapping

        if old_mappings != "":
            # This is not super helpful, but at least we get some detail about which mappings were removed
            change_type = locutus.model.provenance.Provenance.ChangeType.EditMapping

        self.add_provenance(
            change_type=change_type,
            target=code,
            old_value=old_mappings,
            new_value=",".join(new_mappings),
            editor=editor,
        )
        self.save()
        # tmref.document(code_index).set(doc)


    def get_api_preferences(self):
        return {
            "api_preference":  self.api_preferences
        }


    def add_api_preferences(self, api, preferences):
        if len(preferences) > 0:
            self.api_preferences[api] = preferences
            #self.api_preferences.set_preference(api, preferences)

    def remove_api_preferences(self):
        self.api_preferences = {}
        self.save()

    def get_preference(self, code=None):
        prefs = {}
        
        term_prefs = self.get_api_preferences()
    

        if code is not None and code != "self":
            coding = self.get_coding(code)
            if coding:
                cp = coding.get_api_preferences()
                if cp["api_preference"] != {}:
                    prefs[code] = cp
            
        # For terminology preferences
        if prefs == {}:        
            prefs['self'] = term_prefs

        return prefs

    def add_or_update_pref(self, api_preference, code=None):
        if code is None or code == "self":
            self.remove_api_preferences()
            for api in api_preference:
                self.add_api_preferences(api, api_preference[api])
            self.save()
        else:
            coding = self.get_coding(code)
            if coding:
                coding.remove_api_preferences()
                for api in api_preference:
                    coding.add_api_preferences(api, api_preference[api])
                coding.save()

    def remove_pref(self, code=None):
        if code is None or code == "self":
            if len(self.api_preferences) > 0:
                message = f"Successfully deleted preferences for Terminology '{self.name}'."
            else:
                message = f"No preferences found to delete for code '{self.name}'."

            self.remove_api_preferences()
        else:
            coding = self.get_coding(code)
            if coding:
                if len(coding.api_preferences) > 0:
                    message = f"Successfully deleted preferences for code '{code}'."
                else:
                    message = f"No preferences found to delete for code '{code}'."

                coding.remove_api_preferences()
            else:
                message = f"No coding found in {self.name} for code, {code}."

        logger.debug(message)
        return message


    def get_preferred_terminology(self):
        """
        Retrieves all references from the 'preferred_terminology' sub-collection

        Returns:
            list: 'references" - An array of `Terminology` reference dictionaries
        
        Example output:
        {
            "references": [
                {
                    "reference": "Terminology/tm--example1"
                },
                {
                    "reference": "Terminology/tm--example2"
                }
            ]
        } 
        """

        return {
            "references": self.preferred_terminologies
        }

    def replace_preferred_terminology(self, editor, preferred_terminology):
        """
        Creates or replaces a document in the 'preferred_terminology' sub-collection

        Args:
            preferred_terminology (list): A dictionary representing the preferred terminology to be added.

        JSON body with two additions example:
        [
            {
                "preferred_terminology": "tm--example1"
            },
            {
                "preferred_terminology": "tm--example2"
            }
        ]
        """

        self.preferred_terminologies =  [{"reference": f"Terminology/{item['preferred_terminology']}"} for item in preferred_terminology]
        self.save()
        self.add_provenance(
            locutus.model.provenance.Provenance.ChangeType.ReplacePrefTerm,
            target="self",
            new_value=self.preferred_terminologies,
            editor=editor,
        )


    def remove_preferred_terminology(self, editor=None):
        if len(self.preferred_terminologies) > 0:
            message = f"Successfully deleted preferences for '{self.id}'."
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.RemovePrefTerm,
                target="self",
                old_value=",".join([x['reference'] for x in self.preferred_terminologies]),
                editor=editor,
            )
        else:

            message = f"No preferences found to delete for '{self.id}'."
        self.preferred_terminologies = []
        self.save()

        logger.debug(message)
        return message 

    class _Schema(Schema):
        id = fields.Str()
        name = fields.Str(required=True)
        url = fields.URL(required=True)
        description = fields.Str()
        # codes = fields.List(fields.Nested(Coding._Schema))
        codes = fields.List(fields.Nested(SimpleReference._Schema))
        resource_type = fields.Str()
        api_preferences = fields.Dict(keys=fields.Str(), values=fields.List(fields.Str()))
        preferred_terminologies = fields.List(fields.Nested(Reference._Schema))

        @post_load
        def build_terminology(self, data, **kwargs):
            return Terminology(**data)

    def realize_as_dict(self):
        this_term = self.dump()
        this_term['codes'] = []

        for ref in self.codes:
            this_term['codes'].append(ref.dereference().dump())
    
        return this_term

class MappingUserInputModel:
    def generate_mapping_user_input(id, code, mapped_code, user_id):
        """Mappings may have user_input data stored seperate from the mapping itself.
        This function collects and formats the user_input data for a given mapping,
        then creates the user_input object to be included in a CodingMapping.
        """
        code_index = locutus.get_code_index(code)
        mapped_code_index = locutus.get_code_index(mapped_code)

        # Ensure codes/mappings are not placeholders at this point
        code = locutus.normalize_ftd_placeholders(code)

        mapped_code = locutus.normalize_ftd_placeholders(mapped_code)

        conversation = MappingConversation.get(terminology_id=id,
            source_code=code,
            mapped_code=mapped_code,
            return_instance=False)
        votes = MappingVote.get(terminology_id=id,
            source_code=code,
            mapped_code=mapped_code,
            return_instance=False)

        comment_count = 0
        if conversation != []:
            comment_count = len(conversation['mapping_conversations'])

        vote_count = {
            "up": 0,
            "down": 0
        }
        user_vote = ""
        if votes != []:
            vote_count = MappingUserInputModel.get_mapping_votes_counts(votes['mapping_votes'])
            user_vote = votes['mapping_votes'].get(user_id)
            if user_vote is not None:
                user_vote = user_vote['vote']

        return {
            "comments_count": comment_count,
            "votes_count": vote_count,
            "users_vote": user_vote
        }

    def get_mapping_votes_counts(mapping_votes):
        """Counts up and down votes for a given mapping"""
        return {
            "up": sum(
                1 for vote in mapping_votes.values() if vote.get("vote") == "up"
            ),
            "down": sum(
                1 for vote in mapping_votes.values() if vote.get("vote") == "down"
            ),
        }

