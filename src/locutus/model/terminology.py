from .serializable import Serializable
from marshmallow import Schema, fields, post_load

import locutus 

"""
from locutus import (
    persistence,
    PROVENANCE_TIMESTAMP_FORMAT,
    get_code_index,
    FTD_PLACEHOLDERS,
    normalize_ftd_placeholders,
    format_ftd_code
)"""
from locutus.api import delete_collection, generate_paired_string, generate_mapping_index
import locutus.model.exceptions
import locutus.model.lookups 
from enum import StrEnum  # Adds 3.11 requirement or 3.6+ with StrEnum library
from datetime import datetime
import time
from locutus import logger

from locutus.model.lookups import FTDConceptMapTerminology, FTDOntologyLookup
from locutus.model.onto_api_preference import OntoApiPreference
import locutus.model.provenance
from locutus.model.user_input import UserInput
from locutus.sessions import SessionManager

from locutus.model.coding import Coding, BasicCoding
from locutus.model.reference import Reference

import pdb

"""
A terminology exists on its own within the project but can be referenced by 
variables as part of their data-type construction. 

Id:
This should be generated by the system, but can be provided by the user. 

Name:
A Human friendly name associated with the terminology. 

URL:
The terminology's "system" identifier. 

Description:
An optional block of text that is used to provide context for understanding the
terminology's purpose.

Codes:
(Currently, a List) of Codings. Each coding is defined within the scope of the 
terminology's "codes" property. Codings should not appear more than once inside
the "codes" array. 
"""



class Terminology(Serializable):
    _id_prefix = "tm"

    class MappingStatus(StrEnum):
        AwaitingApproval = "Awaiting Approval"
        Approved = "Approved"
        Rejected = "Rejected"

    def __init__(
        self,
        id=None,
        _id=None,
        name=None,
        url=None,
        description=None,
        codes=None,
        resource_type=None,
        preferred_terminologies=[],
        api_preferences={},
        editor=None,
    ):
        super().__init__(
            id=id, _id=_id, collection_type="Terminology", resource_type="Terminology"
        )
        self.name = name
        self.description = description
        self.url = url
        self.codes = []

        self.api_preferences = api_preferences
        self.preferred_terminologies = preferred_terminologies

        super().identify()

        if editor:
            self.save()
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.Create,
                editor=editor,
                target="self",
                new_value="Instantiation"
            )

        # This probably doesn't make sense, stashing the system in at this
        # point, but we'll trust knuth for the time being and fix it when it is
        # clear that it is a bad idea.
        if codes is not None:
            for code in codes:
                if type(code) is dict:
                    code['terminology_id'] = self.id
                    code['system'] = self.url
                    code = Coding(**code)
                # print(code)
                code.system = self.url
                code.save()
                self.codes.append(code)

                if editor:
                    self.add_provenance(
                        locutus.model.provenance.Provenance.ChangeType.AddTerm,
                        editor=editor,
                        target="self",
                        new_value=code.code,
                    )

    def find_match(self, return_instance=True):

        if self.url is not None and self.url.strip() != "" \
            and self.name is not None and self.name.strip() != "":
            params = {
                "url": self.url,
                "name": self.name
            }

            return self.__class__.find(params, return_instance)
        
        raise ValueError(f"Terminology.find_match() requires both a url and name.")

    def delete(self, hard_delete=True):
        if not hard_delete:
            self.valid =False 
            self.save()
            t = self.to_dict()
        else:
            dref = locutus.persistence().collection(self._collection_type).document(self._id)
            t = dref.get().to_dict()

            time_of_delete = dref.delete()
        # Delete all provenance
        for prov in locutus.model.provenance.Provenance.find({"terminology_id": self.id}):
            prov.delete(hard_delete=hard_delete)

        all_codings = locutus.model.coding.Coding.get(
                                terminology_id=self.id,
                                valid_only=False
        )
        if type(all_codings) is locutus.model.coding.Coding:
            all_codings = [all_codings]

        for coding in all_codings:
            coding.delete(hard_delete=hard_delete)

        return t

    @classmethod
    def _delete(cls, id):
        """This is being moved to other places and will no longer be necessary here. 
        mapref = (
            persistence().collection("Terminology").document(id).collection("mappings")
        )
        delete_collection(mapref)
        mapref = (
            persistence().collection("Terminology").document(id).collection("provenance")
        )
        delete_collection(mapref)
        mapref = (
            persistence().collection("Terminology").document(id).collection("onto_api_preference")
        )
        delete_collection(mapref)
        mapref = (
            persistence().collection("Terminology").document(id).collection("preferred_terminology")
        )
        delete_collection(mapref)
        mapref = (
            persistence().collection("Terminology").document(id).collection("user_input")
        )
        delete_collection(mapref)
        """


        dref = locutus.persistence().collection("Terminology").document(id)
        t = dref.get().to_dict()

        time_of_delete = dref.delete()
        return t

    def keys(self):
        return [self.url, self.name]

    def build_code_dict(self):
        codings = {}

        for code in locutus.model.coding.Coding.get(
                                terminology_id=self.id,
                                return_instance=True,
                                valid_only=True):
            codings[code.code] = code

        return codings

    """
    def build_code_list(mapping):
        codes = []
        code_id = mapping["code"]

        for codingmapping in mapping["codes"]:
            codes.append(CodingMapping(**codingmapping))

        return codes
    """

    def add_code(self, code, display, description=None, editor=None):

        coding = locutus.model.coding.Coding.get(
                    terminology_id=self.id,
                    code=code)

        if type(coding) is list and len(coding) != 0:
            # This definitely should not return more than one coding
            raise locutus.model.exceptions.InvalidValueError(code, "too many codes already exist in the database")
        if type(coding) is Coding:
            if coding.valid:
                raise locutus.model.exceptions.CodeAlreadyPresent(code, self.id, coding)
            coding.valid=True
            coding.save()
            new_coding=coding
        else:
            new_coding = Coding(terminology_id=self.id,
                                code=code, 
                                display=display, 
                                description=description,
                                system=self.url, 
                                editor=editor,
                                rank=len(self.codes)
                                )
        for cc in self.codes:
            if cc == code:
                raise locutus.model.exceptions.CodeAlreadyPresent(code, self.id, cc)

        new_coding.save()

        self.codes.append(new_coding)
        self.save()

        if editor:
            # This adds provenance to the Terminology/Table itself
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.AddTerm,
                editor=editor,
                target="self",
                new_value=code,
            )
            # This adds provenance to the code itself
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.AddTerm,
                editor=editor,
                target=code,
            )

    def remove_code(self, code, editor):
        code_found = False
        # Ensure codes are not placeholders at this point.
        code = locutus.normalize_ftd_placeholders(code)

        coding = self.get_coding(code)
        
        if coding is not None:
            # We might want to actually call self.delete_mappings(code=code)
            # if we want to reflect, in provenance, that we lost some mappings
            # However, that wasn't what we were doing, so leaving things as 
            # they were for now
            # EST - 2025-08-18
            coding.valid = False
            self.codes.remove(coding)
            self.save()
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.RemoveTerm,
                editor=editor,
                target="self",
                new_value=code,
            )
            code_found = True
        else:
            msg = f"The terminology, '{self.name}' ({self.id}), has no code, '{code}'"
            logger.error(msg)
            raise KeyError(msg)

    def rename_code(
        self, original_code, new_code, new_display, editor, new_description=None
    ):
        status = 200
        print(
            f"Renaming Code, {original_code} to {new_code} with new display: {new_display} and new description: {new_description}"
        )
        old_values = []
        new_values = []

        for code in self.codes:
            if code.code == original_code:

                # It's not unreasonable we have only been asked to update the
                # display, so no need to wastefully change all of the details
                # about the code when the end result is the same
                if original_code != new_code:
                    old_values.append(f"code: {original_code}")
                    new_values.append(f"code: {new_code}")
                    code.code = new_code

                    # Since we found a matching code, we'll pull the mappings and
                    # save those under the new code after deleting the old ones.
                    mappings = self.mappings(original_code)
                    if original_code in mappings and mappings[original_code] != []:
                        self.set_mapping(new_code, mappings[original_code], editor=editor)
                        self.delete_mappings(code=original_code, editor=editor)

                if new_display is not None and code.display != new_display:
                    old_values.append(f"display: {code.display}")
                    new_values.append(f"display: {new_display}")
                    code.display = new_display

                if new_description is not None and code.description != new_description:
                    old_values.append(f"description: {code.description}")
                    new_values.append(f"description: {new_description}")
                    code.description = new_description

                old_values = ",".join(old_values)
                new_values = ",".join(new_values)

                self.save()
                if new_values:
                    self.add_provenance(
                        change_type=locutus.model.provenance.Provenance.ChangeType.EditTerm,
                        target=original_code,
                        old_value=old_values,
                        new_value=new_values,
                        editor=editor,
                    )
                    self.add_provenance(
                        change_type=locutus.model.provenance.Provenance.ChangeType.EditTerm,
                        target="self",
                        old_value=old_values,
                        new_value=new_values,
                        editor=editor,
                    )
                    if original_code != new_code:
                        prov = locutus.model.provenance.Provenance.mapping_provenance(
                            terminology_id=self.id, 
                            target_coding=original_code, 
                            valid_only=False,
                            return_instance=True
                        )

                        for prv in prov:
                            prv.target=new_code 
                            prv.save()
                    return True
        return False

    def has_code(self, code):
        """Check if a code exists in the terminology.

        Args: 
          code(str): Code to be checked against a Terminologies codes. 
          Terminology codes are currently not cleaned for indexing. For 
          more see get_code_index

        Output:           
         If the terminology has the code already this will return True
        """
        # Ensure codes are not placeholders at this point.
        code = locutus.normalize_ftd_placeholders(code)

        return any(entry.code == code for entry in self.codes)

    def delete_mappings(self, editor, code=None):
        """
        Soft deletes mappings from a terminology document setting the mapping 
        valid field to false.

        Args:
            editor (str): The ID of the user performing the deletion.
            code (str, optional): The specific mapping code to delete. 

        """
        if code is not None:
            # Ensure codes are not placeholders at this point.
            coding = self.get_coding(code)

            old_values = {
                "code": coding.code,
                "codes": coding.delete_mappings()
            }

            self.add_provenance(
                change_type=locutus.model.provenance.Provenance.ChangeType.SoftDeleteMapping,
                target=code,
                old_value=old_values,
                new_value="deleted",
                editor=editor,
            )
            # coding.save()
            
            """
            code = locutus.normalize_ftd_placeholders(code)

            code_index = locutus.get_code_index(code)

            tmref = (
                locutus.persistence()
                .collection("Terminology")
                .document(self.id)
                .collection("mappings")
                .document(code_index)
            )

            mapping = tmref.get().to_dict()
            time_of_delete = 0
            if mapping is not None:
                # Iterate over the codes in the mapping and toggle 'valid' to False
                for codingmapping in mapping["codes"]:
                    codingmapping["valid"] = False

                # Save the updated mapping with the 'valid' field set to False
                tmref.set(mapping)

                self.add_provenance(
                    change_type=locutus.model.provenance.Provenance.ChangeType.SoftDeleteMapping,
                    target=code,
                    old_value=mapping,
                    editor=editor,
                ) """
            if len(old_values['codes']) == 0:
                logger.debug(f"Soft deleting mappings for code: {code}, Terminology: {self.name} but there were no mappings.")

        else:
            for coding in self.codes:
                old_values = {
                    "code": coding.code,
                    "codes": coding.delete_mappings()
                }

                self.add_provenance(
                    change_type=locutus.model.provenance.Provenance.ChangeType.SoftDeleteMapping,
                    target=coding.code,
                    old_value=old_values,
                    new_value="deleted",
                    editor=editor,
                )

                # coding.save()
                """
            mapref = (
                locutus.persistence()
                .collection("Terminology")
                .document(self.id)
                .collection("mappings")
            )

            for mapping_doc in mapref.stream():
                mapping = mapping_doc.to_dict()
                mapping_code_id = mapping["code"]
                code_index = locutus.get_code_index(mapping_code_id)

                for coding in mapping["codes"]:
                    if "valid" in coding:
                        coding["valid"] = False

            
                self.add_provenance(
                    change_type=locutus.model.provenance.Provenance.ChangeType.SoftDeleteMapping,
                    target=mapping_code_id,
                    old_value=mapping,
                    editor=editor,
                )
                # Save the updated mapping
                # mapref.document(code_index).set(mapping)
                """

            self.add_provenance(
                change_type=locutus.model.provenance.Provenance.ChangeType.SoftDeleteAllMappings,
                target="self",
                old_value="valid=True",
                new_value="valid=False",
                editor=editor,
            )

    def mappings(self, code=None):
        codes = {}

        if code is not None:
            coding = self.get_coding(code)
            if coding is None or coding.mappings is None:
                codes[code] = []
            else:
                codes[code] = coding.mappings
        else:
            for code in self.codes:
                codes[code.code] = code.mappings
        return codes
        """
        if code is None:
            for mapping in (
                locutus.persistence()
                .collection(self.resource_type)
                .document(self.id)
                .collection("mappings")
                .stream()
            ):
                mapping = mapping.to_dict()

                code_id = mapping["code"]
                codes[code_id] = Terminology.build_code_list(mapping)

        else:
            code_index = locutus.get_code_index(code)

            mapping = (
                locutus.persistence()
                .collection(self.resource_type)
                .document(self.id)
                .collection("mappings")
                .document(code_index)
                .get()
                .to_dict()
            )
            if mapping is not None:
                code_id = mapping["code"]
                codes[code_id] = Terminology.build_code_list(mapping)
            else:
                codes[code] = []

        return codes
        """

    def get_coding(self, code):
        for item in self.codes:
            if item.code == code:
                return item 
        return None 

    def get_provenance(self, code=None):
        prov = {}

        if code is None:
            # This isn't really relevant any more, but the FE does use it so we will keep it 
            prov['self'] = {}
            prov['self']['target'] = "self"
            changes = []

            for prv in locutus.model.provenance.Provenance.terminology_provenance(terminology_id=self.id):
                if type(prv['timestamp']) is not str:
                    prv['timestamp'] = prv['timestamp'].strftime(
                        locutus.PROVENANCE_TIMESTAMP_FORMAT
                    )
                changes.append(prv)
            prov['self']['changes'] = changes
        else:
            prov[code] = {}
            prov[code]["target"] = code
            changes = []

            for prv in locutus.model.provenance.Provenance.mapping_provenance(terminology_id=self.id, target_coding=code):   
                if prv is not None:             
                    if type(prv['timestamp']) is not str:
                        prv['timestamp'] = prv['timestamp'].strftime(
                            locutus.PROVENANCE_TIMESTAMP_FORMAT
                        )
                    changes.append(prv)
                else:
                    changes = []
            prov[code]['changes'] = changes
        return prov

    def add_provenance(
        self, change_type, editor, target=None, timestamp=None, **kwargs
    ):
        if target is None:
            p = locutus.model.provenance.Provenance.add_terminology_provenance(
                terminology_id=self.id, 
                action=change_type,
                editor=editor,
                timestamp=timestamp,
                **kwargs
            )
        else:
            if target.count("|") > 1:
                print(f"Warning: Invalid target format '{target}'. Skipping provenance addition.")
                return

            if "|" in target:
                left, right = target.split("|", 1)
                # Normalize each side of a paired target for the provenance target/display
                normalized_left = locutus.normalize_ftd_placeholders(left)
                normalized_right = locutus.normalize_ftd_placeholders(right)
                normalized_target = generate_paired_string(normalized_left, normalized_right)

                code_index = target # mapping pairs are already formatted as indexes
            # Ensure special characters in single code targets are handled properly
            else:
                normalized_target = locutus.normalize_ftd_placeholders(target)
                code_index = locutus.get_code_index(target)

            p = locutus.model.provenance.Provenance.add_mapping_provenance(
                terminology_id=self.id, 
                action=change_type,
                editor=editor,
                target_coding=normalized_target,
                timestamp=timestamp,
                **kwargs
            )


    # def add_provenance(self, code, change_type, old_value, new_value, editor, note="via locutus frontend", timestamp=None):

    def set_mapping(self, code, codings, editor):
        code_index = locutus.get_code_index(code)

        # Ensure code is not a placeholder at this point.
        code = locutus.normalize_ftd_placeholders(code)

        doc = {"code": code, "codes": []}

        # Validation of mapping_relationship
        ftd_terminology = FTDConceptMapTerminology()  
        new_mappings = []

        coding = self.get_coding(code)
        old_mappings = ",".join([x.code for x in coding.mappings])
        # Reset the mappings and rebuild them below
        coding.mappings = []
        for mapping in codings:
            coding.mappings.append(mapping)
            coding_dict = mapping.to_dict()

            ftd_terminology.validate_codes_against(coding_dict["mapping_relationship"], additional_enums=[""])

            # Add 'valid' explicitly to the mapping document
            coding_dict['valid'] = True

            doc["codes"].append(coding_dict)
            new_mappings.append(coding_dict["code"])

            for coding_obj in self.codes:
                if coding_obj.code == mapping.code:
                    coding_obj.valid = True
        coding.save()



        change_type = locutus.model.provenance.Provenance.ChangeType.AddMapping
        if old_mappings != "":
            # This is not super helpful, but at least we get some detail about which mappings were removed
            change_type = locutus.model.provenance.Provenance.ChangeType.EditMapping

        self.add_provenance(
            change_type=change_type,
            target=code,
            old_value=old_mappings,
            new_value=",".join(new_mappings),
            editor=editor,
        )
        self.save()
        # tmref.document(code_index).set(doc)


    def get_api_preferences(self):
        return {
            "api_preference":  self.api_preferences
        }


    def add_api_preferences(self, api, preferences):
        if len(preferences) > 0:
            self.api_preferences[api] = preferences
            #self.api_preferences.set_preference(api, preferences)

    def remove_api_preferences(self):
        self.api_preferences = {}

    def get_preference(self, code=None):
        prefs = {}
        if code is not None:
            coding = self.get_coding(code)
            if coding:
                cp = coding.get_api_preferences()
                if cp["api_preference"]:
                    prefs[code] = cp

        # For terminology preferences
        else:        
            cp = self.get_api_preferences()
            if cp['api_preference']:
                prefs['self'] = cp

        return prefs

    def add_or_update_pref(self, api_preference, code=None):
        if code is None:
            self.remove_api_preferences()
            for api in api_preference:
                self.add_api_preferences(api, api_preference[api])
            self.save()
        else:
            coding = self.get_coding(code)
            if coding:
                coding.remove_api_preferences()
                for api in api_preference:
                    coding.add_api_preferences(api, api_preference[api])
                coding.save()

    def remove_pref(self, code=None):
        if code is None:
            if len(self.api_preferences) > 0:
                message = f"Successfully deleted preferences for Terminology '{self.name}'."
            else:
                message = f"No preferences found to delete for code '{self.name}'."

            self.remove_api_preferences()
        else:
            coding = self.get_coding(code)
            if coding:
                if len(coding.api_preferences) > 0:
                    message = f"Successfully deleted preferences for code '{code}'."
                else:
                    message = f"No preferences found to delete for code '{code}'."

                coding.remove_api_preferences()
            else:
                message = f"No coding found in {self.name} for code, {code}."

        logger.debug(message)
        return message
        """
        try:
            # Define the collection reference
            collection_ref = locutus.persistence().collection(self.resource_type) \
                .document(self.id).collection("onto_api_preference")

            code_index = locutus.get_code_index(code)

            doc_ref = collection_ref.document(code_index)
            doc_snapshot = doc_ref.get()

            if doc_snapshot.exists:
                # Delete the document if it exists
                doc_ref.delete()
                message = f"Successfully deleted preferences for code '{code}'."
            else:
                message = f"No preferences found to delete for code '{code}'."

        except Exception as e:
            message = f"An error occurred while deleting preferences for code '{code}': {e}"
            raise

        print(message)

        return message
        """

    def get_preferred_terminology(self):
        """
        Retrieves all references from the 'preferred_terminology' sub-collection

        Returns:
            list: 'references" - An array of `Terminology` reference dictionaries
        
        Example output:
        {
            "references": [
                {
                    "reference": "Terminology/tm--example1"
                },
                {
                    "reference": "Terminology/tm--example2"
                }
            ]
        } 
        """

        return {
            "references": self.preferred_terminologies
        }
        """
        try:
            doc_ref = locutus.persistence().collection(self.resource_type).document(self.id) \
                .collection("preferred_terminology").document("self")

            doc_snapshot = doc_ref.get()
            if doc_snapshot.exists:
                preferred_terms = doc_snapshot.to_dict().get('references', [])
                return {"references": preferred_terms}
            else:
                # Return an empty list for references if no preferred terminology exists
                return {"references": []}

        except Exception as e:
            print(f"An error occurred while retrieving preferred terminology: {e}")
            raise
        """
    def replace_preferred_terminology(self, editor, preferred_terminology):
        """
        Creates or replaces a document in the 'preferred_terminology' sub-collection

        Args:
            preferred_terminology (list): A dictionary representing the preferred terminology to be added.

        JSON body with two additions example:
        [
            {
                "preferred_terminology": "tm--example1"
            },
            {
                "preferred_terminology": "tm--example2"
            }
        ]
        """

        self.preferred_terminologies =  [{"reference": f"Terminology/{item['preferred_terminology']}"} for item in preferred_terminology]
        self.save()
        self.add_provenance(
            locutus.model.provenance.Provenance.ChangeType.ReplacePrefTerm,
            target="self",
            new_value=self.preferred_terminologies,
            editor=editor,
        )

        """
        try:
            # Reference to the sub-collection document named "self"
            doc_ref = locutus.persistence().collection(self.resource_type).document(self.id) \
                .collection("preferred_terminology").document("self")
            
            # Create a list of references based on the provided preferred terminologies
            references = [{"reference": f"Terminology/{item['preferred_terminology']}"} for item in preferred_terminology]

            # Update the document with new combined data
            doc_ref.set({"references": references})

            self.add_provenance(
            locutus.model.provenance.Provenance.ChangeType.ReplacePrefTerm,
            target="self",
            new_value=references,
            editor=editor,
            )

        except Exception as e:
            message = f"An error occurred while adding preferred terminology: {e}"
            logger.error(message)
            raise
        """

    def remove_preferred_terminology(self, editor=None):
        if len(self.preferred_terminologies) > 0:
            message = f"Successfully deleted preferences for '{self.id}'."
            self.add_provenance(
                locutus.model.provenance.Provenance.ChangeType.RemovePrefTerm,
                target="self",
                old_value=",".join([x['reference'] for x in self.preferred_terminologies]),
                editor=editor,
            )
        else:

            message = f"No preferences found to delete for '{self.id}'."
        self.preferred_terminologies = []
        self.save()

        logger.debug(message)
        return message 

        """
        try:
            # Define the collection reference
            collection_ref = locutus.persistence().collection(self.resource_type) \
                .document(self.id).collection("preferred_terminology")

            doc_ref = collection_ref.document("self")
            doc_snapshot = doc_ref.get()

            if doc_snapshot.exists:
                # Delete the document if it exists
                doc_ref.delete()
                message = f"Successfully deleted preferences for '{self.id}'."
            else:
                message = f"No preferences found to delete for '{self.id}'."

        except Exception as e:
            message = f"An error occurred while deleting preferences for '{self.id}': {e}"
            logger.error(message)
            raise

        logger.debug(message)

        return message
        """
    class _Schema(Schema):
        id = fields.Str()
        name = fields.Str(required=True)
        url = fields.URL(required=True)
        description = fields.Str()
        codes = fields.List(fields.Nested(Coding._Schema))
        resource_type = fields.Str()
        api_preferences = fields.Dict(keys=fields.Str(), values=fields.List(fields.Str()))
        preferred_terminologies = fields.List(fields.Nested(Reference._Schema))

        @post_load
        def build_terminology(self, data, **kwargs):
            return Terminology(**data)


class MappingUserInputModel:
    def generate_mapping_user_input(id, code, mapped_code, user_id):
        """Mappings may have user_input data stored seperate from the mapping itself.
        This function collects and formats the user_input data for a given mapping,
        then creates the user_input object to be included in a CodingMapping.
        """
        code_index = locutus.get_code_index(code)
        mapped_code_index = locutus.get_code_index(mapped_code)

        # Ensure codes/mappings are not placeholders at this point
        code = locutus.normalize_ftd_placeholders(code)

        mapped_code = locutus.normalize_ftd_placeholders(mapped_code)

        document_id = generate_mapping_index(code, mapped_code)
        doc_ref = (
            locutus.persistence()
            .collection("Terminology")
            .document(id)
            .collection("user_input")
            .document(document_id)
        )

        comments_count = MappingUserInputModel.get_mapping_conversations_counts(doc_ref)
        votes_count = MappingUserInputModel.get_mapping_votes_counts(doc_ref)
        users_vote = MappingUserInputModel.get_users_mapping_vote(doc_ref, user_id)

        return {
            "comments_count": comments_count,
            "votes_count": votes_count,
            "users_vote": users_vote,
        }

    def get_mapping_conversations_counts(doc_ref):
        """Counts the number of mapping_conversation records for a given mapping"""
        document = doc_ref.get()
        if document.exists:
            data = document.to_dict()
            conversations = data.get("mapping_conversations", [])
            return len(conversations)
        return 0

    def get_mapping_votes_counts(doc_ref):
        """Counts up and down votes for a given mapping"""
        document = doc_ref.get()
        if document.exists:
            data = document.to_dict()
            mapping_votes = data.get("mapping_votes", {})
            return {
                "up": sum(
                    1 for vote in mapping_votes.values() if vote.get("vote") == "up"
                ),
                "down": sum(
                    1 for vote in mapping_votes.values() if vote.get("vote") == "down"
                ),
            }
        return {"up": 0, "down": 0}

    def get_users_mapping_vote(doc_ref, user_id):
        """Retrieves the current user's vote for a given mapping. If the user_id
        is not found(no vote exists for the user, or user_id is unknown/None) an
        empty string is returned."""
        document = doc_ref.get()
        if document.exists:
            data = document.to_dict()
            mapping_votes = data.get("mapping_votes", {})
            user_vote = mapping_votes.get(user_id, {}).get("vote")
            return user_vote if user_vote else ""
        return ""
