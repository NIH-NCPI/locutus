from . import Serializable
from marshmallow import Schema, fields, post_load
from locutus import persistence
from locutus.api import delete_collection

import pdb

"""
A terminology exists on its own within the project but can be referenced by 
variables as part of their data-type construction. 

Id:
This should be generated by the system, but can be provided by the user. 

Name:
A Human friendly name associated with the terminology. 

URL:
The terminology's "system" identifier. 

Description:
An optional block of text that is used to provide context for understanding the
terminology's purpose.

Codes:
(Currently, a List) of Codings. Each coding is defined within the scope of the 
terminology's "codes" property. Codings should not appear more than once inside
the "codes" array. 
"""


class Coding:
    def __init__(self, code, display="", system=None):
        self.code = code
        self.display = display
        self.system = system

    class _Schema(Schema):
        code = fields.Str(
            required=True, error_messages={"required": "Codings *must* have a code "}
        )
        display = fields.Str()
        system = fields.URL()

        @post_load
        def build_code(self, data, **kwargs):
            # pdb.set_trace()
            return Coding(**data)

    def to_dict(self):
        obj = {"code": self.code, "display": self.display}

        if self.system is not None:
            obj["system"] = self.system

        return obj


class Terminology(Serializable):
    _id_prefix = "tm"

    def __init__(
        self,
        id=None,
        name=None,
        url=None,
        description=None,
        codes=None,
        resource_type=None,
    ):
        super().__init__(
            id=id, collection_type="Terminology", resource_type="Terminology"
        )
        self.id = id
        self.name = name
        self.description = description
        self.url = url

        # pdb.set_trace()

        # This probably doesn't make sense, stashing the system in at this
        # point, but we'll trust knuth for the time being and fix it when it is
        # clear that it is a bad idea.
        if codes is not None:
            self.codes = []
            for code in codes:
                if type(code) is dict:
                    code = Coding(**code)
                # print(code)
                code.system = self.url
                self.codes.append(code)
        else:
            self.codes = None

        super().identify()

    def keys(self):
        return [self.url, self.name]

    def build_code_dict(self):
        codings = {}
        for code in self.codes:
            codings[code.code] = code

        return codings

    def build_code_list(mapping):
        codes = []
        code_id = mapping["code"]

        for coding in mapping["codes"]:
            codes.append(Coding(**coding))

        return codes

    def rename_code(self, original_code, new_code):
        status = 200
        for code in self.codes:
            print(f"{self.name} - {code.code} == {original_code}")
            if code.code == original_code:
                code.code = new_code

                print(f"After change, code list is:")
                for c in self.codes:
                    print(f"\t{c.code} - {c.display}")
                self.save()
                # Since we found a matching code, we'll pull the mappings and
                # save those under the new code after deleting the old ones.

                mappings = self.mappings(original_code)
                if original_code in mappings and mappings[original_code] != []:
                    self.set_mapping(new_code, mappings[original_code])
                    self.delete_mappings(original_code)

                return True
        return False

    def delete_mappings(self, code=None):
        if code is not None:
            tmref = (
                persistence()
                .collection("Terminology")
                .document(self.id)
                .collection("mappings")
                .document(code)
            )
            print(f"Deleting mappings for code, {code}, from Terminology, {self.name}")
            time_of_delete = tmref.delete()
            return time_of_delete
        else:
            mapref = (
                persistence()
                .collection("Terminology")
                .document(self.id)
                .collection("mappings")
            )
            print(f"Deleting all mappings for Terminology, {self.name} ")
            mapping_count = delete_collection(mapref)
            return mapping_count

    def mappings(self, code=None):
        codes = {}
        if code is None:
            for mapping in (
                persistence()
                .collection(self.resource_type)
                .document(self.id)
                .collection("mappings")
                .stream()
            ):
                mapping = mapping.to_dict()

                code_id = mapping["code"]
                codes[code_id] = Terminology.build_code_list(mapping)

        else:
            mapping = (
                persistence()
                .collection(self.resource_type)
                .document(self.id)
                .collection("mappings")
                .document(code)
                .get()
                .to_dict()
            )
            if mapping is not None:
                code_id = mapping["code"]
                codes[code_id] = Terminology.build_code_list(mapping)
            else:
                codes[code] = []

        return codes

    def set_mapping(self, code, codings):
        doc = {"code": code, "codes": []}

        for coding in codings:
            doc["codes"].append(coding.to_dict())

        persistence().collection(self.resource_type).document(self.id).collection(
            "mappings"
        ).document(code).set(doc)

    class _Schema(Schema):
        id = fields.Str()
        name = fields.Str(required=True)
        url = fields.URL(required=True)
        description = fields.Str()
        codes = fields.List(fields.Nested(Coding._Schema))
        resource_type = fields.Str()

        @post_load
        def build_terminology(self, data, **kwargs):
            return Terminology(**data)


"""
_term_data = {
    1: Terminology(
        name="Race",
        url="https://includedcc.org/fhir/CodeSystem/data-dictionary/participant/race",
        description="Race of Participant",
        codes=[
            Coding(code="American Indian or Alaska Native"),
            Coding(code="Asian"),
            Coding(code="Black or African American"),
            Coding(code="More than one race"),
            Coding(code="Native Hawaiian or Other Pacific Islander"),
            Coding(code="Other"),
            Coding(code="White"),
            Coding(code="Prefer not to answer"),
            Coding(code="Unknown"),
            Coding(code="East Asian"),
            Coding(code="Latin American"),
            Coding(code="Middle Eastern or North African"),
            Coding(code="South Asian"),
        ],
    ),
    2: Terminology(
        name="Sex",
        url="https://includedcc.org/fhir/CodeSystem/data-dictionary/participant/sex",
        description="Sex of Participant",
        codes=[
            Coding(code="Female"),
            Coding(code="Male"),
            Coding(code="Other"),
            Coding(code="Unknown"),
        ],
    ),
    3: Terminology(
        name="Family Relationship",
        url="https://includedcc.org/fhir/CodeSystem/data-dictionary/participant/family_relationship",
        description="Relationship of Participant to proband",
        codes=[
            Coding(code="Proband"),
            Coding(code="Father"),
            Coding(code="Mother"),
            Coding(code="Sibling"),
            Coding(code="Other relative"),
            Coding(code="Unrelated control"),
        ],
    ),
}


def terminologies(id=None):
    if id is None:
        terms = [v for k, v in _term_data.items()]
        return terms
    return _term_data[id]
"""
